/**
 * History page - completed sessions with stats filter.
 */

import router from '@ohos.router'
import inputMethod from '@ohos.inputMethod'
import { TaskRepo } from '../data/TaskRepo'
import { SessionRepo } from '../data/SessionRepo'
import { SegmentRepo } from '../data/SegmentRepo'
import { BreakRepo } from '../data/BreakRepo'
import { Task } from '../model/Task'
import { FocusSession, SessionType } from '../model/FocusSession'
import { FocusSegment } from '../model/FocusSegment'
import { BreakEvent } from '../model/BreakEvent'
import { SessionStatus } from '../model/SessionStatus'
import { BottomNav } from '../components/BottomNav'
import { OnboardingOverlay } from '../components/OnboardingOverlay'
import { Theme } from '../common/theme'
import { getOnboardingStep, shouldShowOnboarding } from '../onboarding/OnboardingFlow'

class FocusSessionCopy implements FocusSession {
  id: number
  taskId?: number
  startAt: number
  endAt?: number
  status: SessionStatus
  actualFocusDuration: number
  totalDuration: number
  breakCount: number
  interruptionReason?: string
  timeLimitMs?: number
  sessionType: SessionType
  restIntervalMs?: number
  restDurationMs?: number

  constructor(session: FocusSession) {
    this.id = session.id
    this.taskId = session.taskId
    this.startAt = session.startAt
    this.endAt = session.endAt
    this.status = session.status
    this.actualFocusDuration = session.actualFocusDuration
    this.totalDuration = session.totalDuration
    this.breakCount = session.breakCount
    this.interruptionReason = session.interruptionReason
    this.timeLimitMs = session.timeLimitMs
    this.sessionType = session.sessionType
    this.restIntervalMs = session.restIntervalMs
    this.restDurationMs = session.restDurationMs
  }
}

class GroupedSessionBucket {
  session: FocusSession
  restTotal: number

  constructor(session: FocusSession, restTotal: number) {
    this.session = session
    this.restTotal = restTotal
  }
}

@Entry
@Component
struct HistoryPage {
  @State completedSessions: FocusSession[] = []
  @State taskById: Record<number, Task> = {}
  @State expandedSessionIds: number[] = []
  @State loading: boolean = false
  @State filterOpen: boolean = false
  @State selectedDate: Date = new Date()
  @State pickerYear: string = new Date().getFullYear().toString()
  @State pickerMonth: string = (new Date().getMonth() + 1).toString()
  @State pickerDay: string = new Date().getDate().toString()
  @State appliedDate: Date | null = null
  @State hourlyFocus: number[] = []
  @State hourlyRest: number[] = []
  @State headerOpacity: number = 0
  @State contentOpacity: number = 0
  private readonly chartHeight: number = 140
  private readonly axisBaselineOffset: number = 5
  private readonly chartMaxMinutes: number = 60
  private readonly chartItemWidth: number = 35
  private readonly chartBarWidth: number = 8
  private chartScroller: Scroller = new Scroller()
  // æ»‘åŠ¨æ‰‹åŠ¿ç›¸å…³
  @State panOffsetX: number = 0
  private readonly swipeThreshold: number = 80
  @StorageLink('hasSeenOnboarding') hasSeenOnboarding: boolean = false
  @StorageLink('onboardingStepId') onboardingStepId: string = ''
  @StorageLink('onboardingAdvanceTick') onboardingAdvanceTick: number = 0
  @StorageLink('onboardingSkipTick') onboardingSkipTick: number = 0
  @State lastAdvanceTick: number = 0
  @State lastSkipTick: number = 0
  private onboardingTickTimer: number = -1

  private hideKeyboard() {
    try {
      inputMethod.getController().hideTextInput()
    } catch (e) {
      // Ignore when keyboard is not available.
    }
  }

  async aboutToAppear() {
    this.resetHourlyData()
    await this.loadData()
    setTimeout(() => {
      this.headerOpacity = 1
    }, 100)
    setTimeout(() => {
      this.contentOpacity = 1
    }, 200)
    this.startOnboardingTickMonitor()
  }

  onPageShow() {
    this.loadData()
  }

  aboutToDisappear() {
    this.stopOnboardingTickMonitor()
  }

  private handleSwipeGesture(offsetX: number, velocity: number) {
    const absOffset = Math.abs(offsetX)
    const absVelocity = Math.abs(velocity)
    
    // å¿«é€Ÿæ»‘åŠ¨æˆ–æ»‘åŠ¨è·ç¦»è¶³å¤Ÿ
    if (absVelocity > 500 || absOffset > this.swipeThreshold) {
      if (offsetX > 0) {
        // å‘å³æ»‘åŠ¨ - åˆ‡æ¢åˆ°è®¾ç½®é¡µé¢ï¼ˆå†å²æ˜¯ç¬¬1ä¸ªï¼Œå‘å³æ˜¯ç¬¬2ä¸ªè®¾ç½®ï¼‰
        router.replaceUrl({ url: 'pages/SettingsPage' })
      } else if (offsetX < 0) {
        // å‘å·¦æ»‘åŠ¨ - åˆ‡æ¢åˆ°é¦–é¡µ
        router.replaceUrl({ url: 'pages/Index' })
      }
    }
  }

  private startOnboardingTickMonitor() {
    if (this.onboardingTickTimer !== -1) {
      return
    }
    this.lastAdvanceTick = this.onboardingAdvanceTick
    this.lastSkipTick = this.onboardingSkipTick
    this.onboardingTickTimer = setInterval(() => {
      if (!this.shouldShowOnboardingForRoute('HISTORY')) {
        this.lastAdvanceTick = this.onboardingAdvanceTick
        this.lastSkipTick = this.onboardingSkipTick
        return
      }
      if (this.onboardingAdvanceTick !== this.lastAdvanceTick) {
        this.lastAdvanceTick = this.onboardingAdvanceTick
        this.handleOnboardingAdvance()
      }
      if (this.onboardingSkipTick !== this.lastSkipTick) {
        this.lastSkipTick = this.onboardingSkipTick
        this.endOnboarding()
      }
    }, 150)
  }

  private stopOnboardingTickMonitor() {
    if (this.onboardingTickTimer === -1) {
      return
    }
    clearInterval(this.onboardingTickTimer)
    this.onboardingTickTimer = -1
  }

  private getCurrentOnboardingStep() {
    return getOnboardingStep(this.onboardingStepId)
  }

  private shouldShowOnboardingForRoute(route: string): boolean {
    const step = this.getCurrentOnboardingStep()
    if (!step) {
      return false
    }
    if (step.isSetup) {
      return false
    }
    if (!shouldShowOnboarding(this.hasSeenOnboarding)) {
      return false
    }
    return step.route === route
  }

  private handleOnboardingAdvance() {
    const step = this.getCurrentOnboardingStep()
    if (!step) {
      return
    }
    if (step.id === 'end_history_page') {
      this.endOnboarding()
    }
  }

  private endOnboarding() {
    this.hasSeenOnboarding = true
    this.onboardingStepId = ''
  }

  build() {
    Stack() {
      Column() {
      // é¡¶éƒ¨æ ‡é¢˜æ  - ç²¾è‡´ç°ä»£é£æ ¼
      Row() {
        Row({ space: 10 }) {
          Text('ğŸ“Š')
            .fontSize(Theme.FONT_SIZE_LARGE)
          Text('å†å²è®°å½•')
            .fontSize(Theme.FONT_SIZE_LARGE)
            .fontWeight(FontWeight.Bold)
            .fontColor(Theme.COLOR_TEXT_PRIMARY)
        }
        .alignItems(VerticalAlign.Center)
        
        Blank()
        
        Button({ type: ButtonType.Circle }) {
          Text('ğŸ“…')
            .fontSize(20)
        }
        .width(48)
        .height(48)
        .backgroundColor(this.filterOpen ? Theme.COLOR_TEXT_PRIMARY : Theme.COLOR_CARD_BACKGROUND)
        .border({ width: 1, color: Theme.COLOR_BORDER })
        .shadow(Theme.SHADOW_SMALL)
        .onClick(() => {
          if (!this.filterOpen) {
            const base = this.appliedDate ?? this.selectedDate
            this.pickerYear = base.getFullYear().toString()
            this.pickerMonth = (base.getMonth() + 1).toString()
            this.pickerDay = base.getDate().toString()
          }
          this.filterOpen = !this.filterOpen
        })
      }
      .width('100%')
      .padding({ left: 20, right: 20, top: 10, bottom: 16 })
      .alignItems(VerticalAlign.Center)
      .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
      .border({
        width: { bottom: 1 },
        color: Theme.COLOR_BORDER
      })
      .opacity(this.headerOpacity)
      .animation({
        duration: Theme.ANIMATION_NORMAL,
        curve: Curve.EaseOut
      })

      Column() {
        if (this.loading) {
          Column() {
            LoadingProgress()
              .width(48)
              .height(48)
              .color(Theme.COLOR_TEXT_PRIMARY)
            Text('åŠ è½½ä¸­...')
              .fontSize(Theme.FONT_SIZE_MEDIUM)
              .fontColor(Theme.COLOR_TEXT_SECONDARY)
              .margin({ top: 16 })
          }
          .layoutWeight(1)
          .justifyContent(FlexAlign.Center)
        } else {
          this.CompletedSessionsContent()
        }
      }
      .layoutWeight(1)
      .width('100%')
      .opacity(this.contentOpacity)
      .animation({
        duration: Theme.ANIMATION_NORMAL,
        curve: Curve.EaseOut
      })

        BottomNav({ currentIndex: 1 })
      }
      .width('100%')
      .height('100%')
      .backgroundColor(Theme.COLOR_BACKGROUND)
      .onTouch((event: TouchEvent) => {
        if (event.type === TouchType.Down) {
          this.hideKeyboard()
        }
      })
      .gesture(
        PanGesture({ direction: PanDirection.Horizontal })
          .onActionUpdate((event: GestureEvent) => {
            this.panOffsetX = event.offsetX
          })
          .onActionEnd((event: GestureEvent) => {
            this.handleSwipeGesture(event.offsetX, event.velocityX)
            this.panOffsetX = 0
          })
      )

      if (this.shouldShowOnboardingForRoute('HISTORY')) {
        OnboardingOverlay({
          visible: true,
          body: this.getCurrentOnboardingStep()?.body ?? '',
          rule: this.getCurrentOnboardingStep()?.rule ?? 'TAP_ANYWHERE_EXCEPT_SKIP',
          showSkip: true
        })
      }
    }
    .width('100%')
    .height('100%')
  }

  @Builder
  CompletedSessionsContent() {
    Stack() {
      Column({ space: Theme.SPACE_MEDIUM }) {
        if (this.appliedDate) {
          this.HourlyChart()
        }

        if (this.getVisibleSessions().length === 0) {
          Column({ space: 16 }) {
            Column() {
              Text('ğŸ“­')
                .fontSize(56)
            }
            .width(100)
            .height(100)
            .borderRadius(50)
            .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
            .border({ width: 1, color: Theme.COLOR_BORDER })
            .justifyContent(FlexAlign.Center)
            
            Text('æš‚æ— å®Œæˆçš„ä»»åŠ¡')
              .fontSize(Theme.FONT_SIZE_LARGE)
              .fontWeight(FontWeight.Medium)
              .fontColor(Theme.COLOR_TEXT_SECONDARY)
            Text('å®Œæˆä¸“æ³¨åï¼Œè®°å½•ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ')
              .fontSize(Theme.FONT_SIZE_SMALL)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
          }
          .justifyContent(FlexAlign.Center)
          .layoutWeight(1)
        } else {
          List({ space: Theme.SPACE_MEDIUM }) {
            ForEach(this.getVisibleSessions(), (session: FocusSession) => {
              ListItem() {
                this.SessionCard(session)
              }
            }, (session: FocusSession) => session.id.toString())
          }
          .width('100%')
        }
      }
      .width('100%')

      if (this.filterOpen) {
        Column({ space: 16 }) {
          Row({ space: 8 }) {
            Text('ğŸ“†')
              .fontSize(Theme.FONT_SIZE_MEDIUM)
            Text('é€‰æ‹©æ—¥æœŸ')
              .fontSize(Theme.FONT_SIZE_MEDIUM)
              .fontWeight(FontWeight.Medium)
              .fontColor(Theme.COLOR_TEXT_PRIMARY)
          }
          .width('100%')

          Row({ space: 10 }) {
            // Year è¾“å…¥
            Column({ space: 6 }) {
              Text('å¹´')
                .fontSize(Theme.FONT_SIZE_SMALL)
                .fontColor(Theme.COLOR_TEXT_SECONDARY)
              TextInput({ placeholder: 'YYYY', text: this.pickerYear })
                .width('100%')
                .height(52)
                .borderRadius(Theme.BORDER_RADIUS_MEDIUM)
                .backgroundColor(Theme.COLOR_BACKGROUND)
                .border({ width: 1.5, color: Theme.COLOR_BORDER })
                .padding({ left: 12, right: 12 })
                .textAlign(TextAlign.Center)
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .onChange((value: string) => {
                  this.pickerYear = value.replace(/[^\d]/g, '')
                })
            }
            .layoutWeight(1)

            // Month è¾“å…¥
            Column({ space: 6 }) {
              Text('æœˆ')
                .fontSize(Theme.FONT_SIZE_SMALL)
                .fontColor(Theme.COLOR_TEXT_SECONDARY)
              TextInput({ placeholder: 'MM', text: this.pickerMonth })
                .width('100%')
                .height(52)
                .borderRadius(Theme.BORDER_RADIUS_MEDIUM)
                .backgroundColor(Theme.COLOR_BACKGROUND)
                .border({ width: 1.5, color: Theme.COLOR_BORDER })
                .padding({ left: 12, right: 12 })
                .textAlign(TextAlign.Center)
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .onChange((value: string) => {
                  this.pickerMonth = value.replace(/[^\d]/g, '')
                })
            }
            .layoutWeight(1)

            // Day è¾“å…¥
            Column({ space: 6 }) {
              Text('æ—¥')
                .fontSize(Theme.FONT_SIZE_SMALL)
                .fontColor(Theme.COLOR_TEXT_SECONDARY)
              TextInput({ placeholder: 'DD', text: this.pickerDay })
                .width('100%')
                .height(52)
                .borderRadius(Theme.BORDER_RADIUS_MEDIUM)
                .backgroundColor(Theme.COLOR_BACKGROUND)
                .border({ width: 1.5, color: Theme.COLOR_BORDER })
                .padding({ left: 12, right: 12 })
                .textAlign(TextAlign.Center)
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .onChange((value: string) => {
                  this.pickerDay = value.replace(/[^\d]/g, '')
                })
            }
            .layoutWeight(1)
          }

          Row({ space: 12 }) {
            Button('åº”ç”¨ç­›é€‰')
              .layoutWeight(1)
              .height(50)
              .fontSize(Theme.FONT_SIZE_MEDIUM)
              .fontWeight(FontWeight.Bold)
              .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
              .fontColor(Theme.COLOR_TEXT_PRIMARY)
              .border({ width: 1, color: Theme.COLOR_BORDER })
              .borderRadius(Theme.BORDER_RADIUS_LARGE)
              .shadow(Theme.SHADOW_GLOW)
              .onClick(() => {
                void this.applyFilter()
              })

            Button('æ¸…é™¤')
              .layoutWeight(1)
              .height(50)
              .fontSize(Theme.FONT_SIZE_MEDIUM)
              .backgroundColor(Theme.COLOR_BACKGROUND)
              .fontColor(Theme.COLOR_TEXT_SECONDARY)
              .borderRadius(Theme.BORDER_RADIUS_LARGE)
              .border({ width: 1, color: Theme.COLOR_BORDER })
              .onClick(() => {
                this.clearFilter()
              })
          }
        }
        .width('100%')
        .padding(20)
        .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
        .border({
          width: { bottom: 1 },
          color: Theme.COLOR_BORDER
        })
        .shadow(Theme.SHADOW_MEDIUM)
        .position({ x: 0, y: 0 })
        .zIndex(2)
      }
    }
    .layoutWeight(1)
    .width('100%')
    .padding({
      left: 20,
      right: 20,
      top: Theme.SPACE_MEDIUM,
      bottom: Theme.SPACE_MEDIUM
    })
  }

  @Builder
  HourlyChart() {
    Column({ space: 12 }) {
      // å›¾ä¾‹
      Row() {
        Text(this.formatDateShort(this.appliedDate!.getTime()))
          .fontSize(Theme.FONT_SIZE_SMALL)
          .fontWeight(FontWeight.Medium)
          .fontColor(Theme.COLOR_TEXT_PRIMARY)
        Row({ space: 16 }) {
          Row({ space: 8 }) {
            Column()
              .width(14)
              .height(14)
              .backgroundColor('#ED820E')
              .borderRadius(7)
            Text('ä¼‘æ¯')
              .fontSize(Theme.FONT_SIZE_SMALL)
              .fontColor(Theme.COLOR_TEXT_SECONDARY)
          }
          Row({ space: 8 }) {
            Column()
              .width(14)
              .height(14)
              .backgroundColor(Theme.COLOR_PRIMARY)
              .borderRadius(7)
            Text('ä¸“æ³¨')
              .fontSize(Theme.FONT_SIZE_SMALL)
              .fontColor(Theme.COLOR_TEXT_SECONDARY)
          }
        }
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(VerticalAlign.Center)

      Text('åˆ†é’Ÿ')
        .fontSize(Theme.FONT_SIZE_TINY)
        .fontColor(Theme.COLOR_TEXT_TERTIARY)
        .margin({ left: 2 })

      Row({ space: Theme.SPACE_SMALL }) {
        Column() {
          Column() {
            Text('60')
              .fontSize(Theme.FONT_SIZE_TINY)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
            Text('45')
              .fontSize(Theme.FONT_SIZE_TINY)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
            Text('30')
              .fontSize(Theme.FONT_SIZE_TINY)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
            Text('15')
              .fontSize(Theme.FONT_SIZE_TINY)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
            Text('0')
              .fontSize(Theme.FONT_SIZE_TINY)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
          }
          .height(this.chartHeight + this.axisBaselineOffset)
          .justifyContent(FlexAlign.SpaceBetween)
        }
        .width(32)
        .height(this.chartHeight + this.axisBaselineOffset)

      Scroll(this.chartScroller) {
        Row({ space: 0 }) {
          ForEach(this.hourlyFocus, (value: number, index: number) => {
            Column() {
                Column({ space: 0 }) {
                  Column()
                    .width(this.chartBarWidth)
                    .height(this.getStackRestHeight(index))
                    .backgroundColor('#ED820E')
                    .borderRadius(6)
                  Column()
                    .width(this.chartBarWidth)
                    .height(this.getStackFocusHeight(index))
                    .backgroundColor(Theme.COLOR_PRIMARY)
                    .borderRadius(6)
                }
                .justifyContent(FlexAlign.End)
                .alignItems(HorizontalAlign.Center)
                .height(this.chartHeight)
                .width(28)
                Text(index.toString())
                  .fontSize(Theme.FONT_SIZE_TINY)
                  .fontColor(Theme.COLOR_TEXT_SECONDARY)
                  .margin({ top: 8 })
              }
              .width(28)
              .height(this.chartHeight + 20)
            })
          }
          .height(this.chartHeight + 30)
          .padding({ right: Theme.SPACE_LARGE })
        }
        .height(this.chartHeight + 30)
        .layoutWeight(1)
        .scrollable(ScrollDirection.Horizontal)
        .scrollBar(BarState.On)
        .onAppear(() => {
          setTimeout(() => {
            if (this.appliedDate) {
              this.scrollChartToFirstActiveHour()
            }
          }, 0)
        })
      }
      .alignItems(VerticalAlign.Top)
      .width('100%')
      .clip(true)
    }
    .width('100%')
    .padding({ left: Theme.SPACE_LARGE, right: Theme.SPACE_LARGE, top: Theme.SPACE_MEDIUM, bottom: Theme.SPACE_MEDIUM })
    .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
    .borderRadius(Theme.BORDER_RADIUS_LARGE)
    .shadow(Theme.SHADOW_MEDIUM)
  }

  @Builder
  SessionCard(session: FocusSession) {
    Column({ space: Theme.SPACE_SMALL }) {
      Row() {
        Column({ space: 6 }) {
          Row({ space: 10 }) {
            Text(this.getTaskTitle(session.taskId))
              .fontSize(Theme.FONT_SIZE_MEDIUM)
              .fontWeight(FontWeight.Bold)
              .fontColor(Theme.COLOR_TEXT_PRIMARY)
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
            if (this.appliedDate && this.isTaskIncomplete(session.taskId)) {
              Text('è¿›è¡Œä¸­')
                .fontSize(Theme.FONT_SIZE_TINY)
                .fontWeight(FontWeight.Medium)
                .fontColor(Theme.COLOR_TEXT_PRIMARY)
                .padding({ left: 8, right: 8, top: 4, bottom: 4 })
                .borderRadius(Theme.BORDER_RADIUS_SMALL)
                .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
                .border({ width: 1, color: Theme.COLOR_BORDER })
            }
          }
          if (!(this.appliedDate && this.isTaskIncomplete(session.taskId))) {
            Text(`å®Œæˆäº: ${this.formatDate(this.getCompletionTime(session))}`)
              .fontSize(Theme.FONT_SIZE_SMALL)
              .fontColor(Theme.COLOR_TEXT_TERTIARY)
          }
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)

        Column({ space: 4 }) {
          Text(this.formatDurationShort(session.actualFocusDuration))
            .fontSize(Theme.FONT_SIZE_LARGE)
            .fontWeight(FontWeight.Bold)
            .fontColor(Theme.COLOR_TEXT_PRIMARY)
          Text('ä¸“æ³¨æ—¶é•¿')
            .fontSize(Theme.FONT_SIZE_TINY)
            .fontColor(Theme.COLOR_TEXT_TERTIARY)
        }

        Stack({ alignContent: Alignment.Center }) {
          Text(this.isSessionExpanded(session.id) ? 'â–¾' : 'â–¸')
            .fontSize(Theme.FONT_SIZE_LARGE)
            .fontWeight(FontWeight.Bold)
            .fontColor(Theme.COLOR_TEXT_TERTIARY)
        }
        .width(24)
        .height(24)
        .margin({ left: 10 })
      }
      .width('100%')

      if (this.isSessionExpanded(session.id)) {
        Column({ space: 12 }) {
          Divider()
            .color(Theme.COLOR_BORDER)
            .margin({ top: 4 })
          
          Row({ space: 16 }) {
            Column({ space: 4 }) {
              Row({ space: 4 }) {
                Text('â±ï¸')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                Text('æ€»æ—¶é•¿')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                  .fontColor(Theme.COLOR_TEXT_TERTIARY)
              }
              Text(this.formatDurationShort(session.totalDuration))
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .fontWeight(FontWeight.Medium)
                .fontColor(Theme.COLOR_TEXT_PRIMARY)
            }
            .layoutWeight(1)
            .alignItems(HorizontalAlign.Start)
            
            Column({ space: 4 }) {
              Row({ space: 4 }) {
                Text('ğŸ¯')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                Text('ä¸“æ³¨æ—¶é•¿')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                  .fontColor(Theme.COLOR_TEXT_TERTIARY)
              }
              Text(this.formatDurationShort(session.actualFocusDuration))
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .fontWeight(FontWeight.Medium)
                .fontColor(Theme.COLOR_TEXT_PRIMARY)
            }
            .layoutWeight(1)
            .alignItems(HorizontalAlign.Start)
          }

          Row({ space: 16 }) {
            Column({ space: 4 }) {
              Row({ space: 4 }) {
                Text('â˜•')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                Text('ä¼‘æ¯æ¬¡æ•°')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                  .fontColor(Theme.COLOR_TEXT_TERTIARY)
              }
              Text(session.breakCount.toString() + ' æ¬¡')
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .fontWeight(FontWeight.Medium)
                .fontColor(Theme.COLOR_TEXT_PRIMARY)
            }
            .layoutWeight(1)
            .alignItems(HorizontalAlign.Start)
            
            Column({ space: 4 }) {
              Row({ space: 4 }) {
                Text('ğŸ˜´')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                Text('ä¼‘æ¯æ—¶é•¿')
                  .fontSize(Theme.FONT_SIZE_SMALL)
                  .fontColor(Theme.COLOR_TEXT_TERTIARY)
              }
              Text(this.formatDurationShort(this.getRestDuration(session)))
                .fontSize(Theme.FONT_SIZE_MEDIUM)
                .fontWeight(FontWeight.Medium)
                .fontColor(Theme.COLOR_TEXT_SECONDARY)
            }
            .layoutWeight(1)
            .alignItems(HorizontalAlign.Start)
          }
        }
        .padding({ top: 4 })
      }
    }
    .width('100%')
    .padding(Theme.SPACE_LARGE)
    .backgroundColor(Theme.COLOR_CARD_BACKGROUND)
    .borderRadius(Theme.BORDER_RADIUS_LARGE)
    .shadow(Theme.SHADOW_MEDIUM)
    .onClick(() => {
      this.toggleExpanded(session.id)
    })
    .animation({
      duration: Theme.ANIMATION_NORMAL,
      curve: Curve.EaseOut
    })
  }

  private async loadData() {
    this.loading = true
    const sessionsResult = await SessionRepo.findCompleted(getContext(this), 200)
    if (sessionsResult.ok && sessionsResult.data) {
      this.completedSessions = sessionsResult.data
      await this.loadTaskMap(sessionsResult.data)
    }
    if (this.appliedDate) {
      await this.loadHourlyDataForDate(this.appliedDate)
    }
    this.loading = false
  }

  private formatDurationShort(ms: number): string {
    const minutes = Math.floor(ms / (1000 * 60))
    const hours = Math.floor(minutes / 60)

    if (hours > 0) {
      return hours + 'h ' + (minutes % 60) + 'm'
    } else {
      return minutes + 'm'
    }
  }

  private formatDate(timestamp: number): string {
    const date = new Date(timestamp)
    const month = date.getMonth() + 1
    const day = date.getDate()
    const hour = date.getHours()
    const minute = date.getMinutes()

    return month + '/' + day + ' ' + this.pad(hour) + ':' + this.pad(minute)
  }

  private pad(num: number): string {
    return num < 10 ? '0' + num : num.toString()
  }

  private formatDateShort(timestamp: number): string {
    const date = new Date(timestamp)
    const month = date.getMonth() + 1
    const day = date.getDate()
    return month + '/' + day
  }

  private getDateFromPicker(year: number, month: number, day: number): Date {
    let monthIndex = month
    if (monthIndex >= 1 && monthIndex <= 12) {
      monthIndex -= 1
    }
    if (monthIndex < 0) {
      monthIndex = 0
    }
    if (monthIndex > 11) {
      monthIndex = 11
    }
    const maxDay = new Date(year, monthIndex + 1, 0).getDate()
    const safeDay = Math.min(Math.max(day, 1), maxDay)
    return new Date(year, monthIndex, safeDay)
  }

  private toggleExpanded(sessionId: number) {
    const index = this.expandedSessionIds.indexOf(sessionId)
    if (index >= 0) {
      this.expandedSessionIds.splice(index, 1)
    } else {
      this.expandedSessionIds.push(sessionId)
    }
    this.expandedSessionIds = [...this.expandedSessionIds]
  }

  private getTaskTitle(taskId?: number): string {
    if (taskId === undefined) {
      return 'Anonymous'
    }
    const task = this.taskById[taskId]
    return task?.title ?? 'Unknown Task'
  }

  private isTaskIncomplete(taskId?: number): boolean {
    if (taskId === undefined) {
      return false
    }
    const task = this.taskById[taskId]
    if (!task) {
      return true
    }
    return task.lastCompletedAt === undefined
  }

  private getVisibleSessions(): FocusSession[] {
    const filtered = this.filterSessionsByDate(this.completedSessions, this.appliedDate)
    return this.groupSessions(filtered, this.appliedDate !== null)
  }

  private filterSessionsByDate(sessions: FocusSession[], date: Date | null): FocusSession[] {
    if (!date) {
      return sessions
    }
    const start = new Date(date)
    start.setHours(0, 0, 0, 0)
    const end = new Date(start)
    end.setDate(end.getDate() + 1)
    const startMs = start.getTime()
    const endMs = end.getTime()
    return sessions.filter((session) => {
      const ts = session.endAt ?? session.startAt
      return ts >= startMs && ts < endMs
    })
  }

  private groupSessions(sessions: FocusSession[], groupByDay: boolean): FocusSession[] {
    const grouped: Record<string, GroupedSessionBucket> = {}
    const keys: string[] = []

    sessions.forEach((session) => {
      if (!groupByDay && this.isTaskIncomplete(session.taskId)) {
        return
      }
      let key = ''
      if (session.taskId !== undefined) {
        key = `task:${session.taskId}`
        if (groupByDay) {
          key += `:${this.getDayKey(this.getCompletionTime(session))}`
        }
      } else {
        key = `session:${session.id}`
      }

      if (!grouped[key]) {
        const copy = new FocusSessionCopy(session)
        copy.status = SessionStatus.FINISHED
        grouped[key] = new GroupedSessionBucket(copy, this.getRestDuration(session))
        keys.push(key)
        return
      }

      const target = grouped[key]
      const targetSession = target.session
      targetSession.actualFocusDuration += session.actualFocusDuration
      targetSession.totalDuration += session.totalDuration
      targetSession.breakCount += session.breakCount
      target.restTotal += this.getRestDuration(session)
      targetSession.startAt = Math.min(targetSession.startAt, session.startAt)

      const completion = this.getCompletionTime(session)
      const targetCompletion = this.getCompletionTime(targetSession)
      if (completion > targetCompletion) {
        targetSession.endAt = session.endAt ?? completion
      }
    })

    return keys.map((key) => {
      const item = grouped[key]
      item.session.restDurationMs = item.restTotal
      return item.session
    })
  }

  private getDayKey(timestamp: number): string {
    const date = new Date(timestamp)
    const month = this.pad(date.getMonth() + 1)
    const day = this.pad(date.getDate())
    return `${date.getFullYear()}-${month}-${day}`
  }

  private async applyFilter(): Promise<void> {
    const year = Number(this.pickerYear)
    const month = Number(this.pickerMonth)
    const day = Number(this.pickerDay)
    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {
      return
    }
    this.selectedDate = this.getDateFromPicker(year, month, day)
    this.appliedDate = new Date(this.selectedDate)
    await this.loadHourlyDataForDate(this.appliedDate)
    this.filterOpen = false
  }

  private clearFilter() {
    this.appliedDate = null
    this.filterOpen = false
    this.resetHourlyData()
  }

  private resetHourlyData() {
    const focus: number[] = []
    const rest: number[] = []
    for (let i = 0; i < 24; i += 1) {
      focus.push(0)
      rest.push(0)
    }
    this.hourlyFocus = focus
    this.hourlyRest = rest
  }

  private async loadHourlyDataForDate(date: Date) {
    const start = new Date(date)
    start.setHours(0, 0, 0, 0)
    const end = new Date(start)
    end.setDate(end.getDate() + 1)
    const startMs = start.getTime()
    const endMs = end.getTime()

    const results = await Promise.all([
      SegmentRepo.findByTimeRange(getContext(this), startMs, endMs),
      BreakRepo.findByTimeRange(getContext(this), startMs, endMs)
    ])
    const segmentsResult = results[0]
    const breaksResult = results[1]

    const focus: number[] = []
    const rest: number[] = []
    for (let i = 0; i < 24; i += 1) {
      focus.push(0)
      rest.push(0)
    }

    if (segmentsResult.ok && segmentsResult.data) {
      segmentsResult.data.forEach((segment: FocusSegment) => {
        const segmentEnd = segment.endAt ?? (segment.startAt + segment.durationMs)
        this.addDurationToHourly(focus, segment.startAt, segmentEnd, startMs, endMs)
      })
    }

    if (breaksResult.ok && breaksResult.data) {
      breaksResult.data.forEach((breakEvent: BreakEvent) => {
        const breakEnd = breakEvent.endAt ?? (breakEvent.startAt + breakEvent.actualDuration)
        this.addDurationToHourly(rest, breakEvent.startAt, breakEnd, startMs, endMs)
      })
    }

    this.hourlyFocus = focus
    this.hourlyRest = rest
    setTimeout(() => {
      if (this.appliedDate) {
        this.scrollChartToFirstActiveHour()
      }
    }, 0)
  }

  private addDurationToHourly(
    target: number[],
    startMs: number,
    endMs: number,
    dayStart: number,
    dayEnd: number
  ) {
    const clampedStart = Math.max(startMs, dayStart)
    const clampedEnd = Math.min(endMs, dayEnd)
    if (clampedEnd <= clampedStart) {
      return
    }

    let cursor = clampedStart
    while (cursor < clampedEnd) {
      const hour = new Date(cursor).getHours()
      const nextHour = this.getNextHourBoundary(cursor)
      const segmentEnd = Math.min(clampedEnd, nextHour)
      const minutes = (segmentEnd - cursor) / 60000
      target[hour] += minutes
      cursor = segmentEnd
    }
  }

  private getNextHourBoundary(timeMs: number): number {
    const dt = new Date(timeMs)
    dt.setMinutes(60, 0, 0)
    return dt.getTime()
  }

  private isSessionExpanded(sessionId: number): boolean {
    return this.expandedSessionIds.includes(sessionId)
  }

  private getCompletionTime(session: FocusSession): number {
    return session.endAt ?? session.startAt
  }

  private getRestDuration(session: FocusSession): number {
    if (session.restDurationMs !== undefined) {
      return session.restDurationMs
    }
    return Math.max(session.totalDuration - session.actualFocusDuration, 0)
  }

  private getBarHeight(value: number): number {
    const height = (value / this.chartMaxMinutes) * this.chartHeight
    return Math.min(height, this.chartHeight)
  }

  private getStackScale(index: number): number {
    const focus = this.hourlyFocus[index] ?? 0
    const rest = this.hourlyRest[index] ?? 0
    const total = focus + rest
    if (total <= this.chartMaxMinutes) {
      return 1
    }
    return this.chartMaxMinutes / total
  }

  private getStackFocusHeight(index: number): number {
    const focus = this.hourlyFocus[index] ?? 0
    const scale = this.getStackScale(index)
    return this.getBarHeight(focus * scale)
  }

  private getStackRestHeight(index: number): number {
    const rest = this.hourlyRest[index] ?? 0
    const scale = this.getStackScale(index)
    return this.getBarHeight(rest * scale)
  }

  private async loadTaskMap(sessions: FocusSession[]) {
    const ids: number[] = []
    sessions.forEach((session) => {
      if (session.taskId !== undefined && !ids.includes(session.taskId)) {
        ids.push(session.taskId)
      }
    })
    const taskMap: Record<number, Task> = {}
    await Promise.all(ids.map(async (id) => {
      const result = await TaskRepo.findById(getContext(this), id)
      if (result.ok && result.data) {
        taskMap[id] = result.data
      }
    }))
    this.taskById = taskMap
  }

  private scrollChartToHour(hour: number) {
    const offset = Math.max(0, hour * this.chartItemWidth)
    this.chartScroller.scrollTo({
      xOffset: offset,
      yOffset: 0,
      animation: false
    })
  }

  private scrollChartToFirstActiveHour() {
    let firstActive = -1
    for (let i = 0; i < 24; i += 1) {
      if ((this.hourlyFocus[i] ?? 0) > 0 || (this.hourlyRest[i] ?? 0) > 0) {
        firstActive = i
        break
      }
    }
    if (firstActive === -1) {
      this.scrollChartToHour(0)
      return
    }
    const startHour = Math.max(0, firstActive - 4)
    this.scrollChartToHour(startHour)
  }
}
